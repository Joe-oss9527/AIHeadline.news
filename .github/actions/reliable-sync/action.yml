name: 'Reliable News Data Sync'
description: 'Enhanced submodule sync with better error handling and recovery'
inputs:
  submodule-path:
    description: 'Path to the submodule'
    required: false
    default: 'source-news'
  submodule-url:
    description: 'URL of the submodule repository'
    required: false
    default: 'https://github.com/Joe-oss9527/ai-briefing-archive.git'
  max-retries:
    description: 'Maximum number of retry attempts'
    required: false
    default: '5'
  retry-delay:
    description: 'Delay between retries in seconds'
    required: false
    default: '10'

outputs:
  sync-status:
    description: 'Status of the sync operation (success/failed/no-changes)'
    value: ${{ steps.sync.outputs.status }}
  old-commit:
    description: 'Previous submodule commit hash'
    value: ${{ steps.sync.outputs.old_commit }}
  new-commit:
    description: 'New submodule commit hash'
    value: ${{ steps.sync.outputs.new_commit }}

runs:
  using: 'composite'
  steps:
    - name: Enhanced submodule sync
      id: sync
      shell: bash
      run: |
        set -euo pipefail

        SUBMODULE_PATH="${{ inputs.submodule-path }}"
        SUBMODULE_URL="${{ inputs.submodule-url }}"
        MAX_RETRIES="${{ inputs.max-retries }}"
        RETRY_DELAY="${{ inputs.retry-delay }}"

        # ============================================================================
        # 函数定义
        # ============================================================================

        sync_submodule() {
          echo "::group::Syncing submodule"

          # 1. 完全清理现有子模块配置
          echo "::notice::Cleaning existing submodule configuration"
          if [[ -d "$SUBMODULE_PATH" ]]; then
            git submodule deinit -f "$SUBMODULE_PATH" 2>/dev/null || true
            git rm -f "$SUBMODULE_PATH" 2>/dev/null || true
            rm -rf "$SUBMODULE_PATH"
          fi

          # 清理 Git 模块缓存
          rm -rf ".git/modules/$SUBMODULE_PATH" 2>/dev/null || true

          # 清理 .gitmodules 中的配置
          if [[ -f ".gitmodules" ]]; then
            git config -f .gitmodules --remove-section "submodule.$SUBMODULE_PATH" 2>/dev/null || true
          fi

          # 重置任何潜在的Git状态问题
          git reset --hard HEAD 2>/dev/null || true

          # 2. 重新添加子模块
          echo "::notice::Adding submodule fresh"
          if ! git submodule add -f "$SUBMODULE_URL" "$SUBMODULE_PATH"; then
            echo "::error::Failed to add submodule"
            echo "::endgroup::"
            return 1
          fi

          # 3. 初始化并更新子模块
          echo "::notice::Initializing and updating submodule"
          if ! git submodule update --init --remote "$SUBMODULE_PATH"; then
            echo "::error::Failed to update submodule"
            echo "::endgroup::"
            return 1
          fi

          # 4. 确保子模块在正确的分支上（解决 detached HEAD 问题）
          echo "::notice::Ensuring submodule is on main branch"
          cd "$SUBMODULE_PATH"

          # 检查并切换到主分支
          if git show-ref --verify --quiet refs/heads/main; then
            git checkout main
          elif git show-ref --verify --quiet refs/heads/master; then
            git checkout master
          else
            # 如果没有本地分支，基于远程分支创建
            if git show-ref --verify --quiet refs/remotes/origin/main; then
              git checkout -b main origin/main
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              git checkout -b master origin/master
            else
              echo "::error::Cannot find main/master branch"
              cd ..
              echo "::endgroup::"
              return 1
            fi
          fi

          # 5. 确保是最新的内容
          echo "::notice::Pulling latest content"
          CURRENT_BRANCH=$(git branch --show-current)
          if ! git pull origin "$CURRENT_BRANCH"; then
            echo "::error::Failed to pull latest changes"
            cd ..
            echo "::endgroup::"
            return 1
          fi

          cd ..
          echo "::notice::Submodule sync completed successfully"
          echo "::endgroup::"
          return 0
        }

        verify_sync_result() {
          echo "::group::Verifying sync result"

          if [[ ! -d "$SUBMODULE_PATH" ]]; then
            echo "::error::Submodule directory does not exist"
            echo "::endgroup::"
            return 1
          fi

          cd "$SUBMODULE_PATH"

          # 检查是否在分支上（而不是 detached HEAD）
          if ! git symbolic-ref HEAD > /dev/null 2>&1; then
            echo "::error::Submodule is in detached HEAD state"
            cd ..
            echo "::endgroup::"
            return 1
          fi

          # 检查是否在最新提交上
          CURRENT_COMMIT=$(git rev-parse HEAD)
          if [[ "$CURRENT_COMMIT" != "$LATEST_REMOTE_COMMIT" ]]; then
            echo "::warning::Submodule not at latest commit, but on branch"
            echo "Current: $CURRENT_COMMIT"
            echo "Latest:  $LATEST_REMOTE_COMMIT"
            # 这是可接受的，只要在分支上
          fi

          # 检查是否有内容文件
          if ! find . -name "briefing_*.md" -type f | head -1 | grep -q .; then
            echo "::error::No briefing files found in submodule"
            cd ..
            echo "::endgroup::"
            return 1
          fi

          # 检查最新文件的时间
          LATEST_FILE=$(find . -name "briefing_*.md" -type f -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2- || echo "")
          if [[ -n "$LATEST_FILE" ]]; then
            echo "::notice::Latest briefing file: $(basename "$LATEST_FILE")"
          fi

          cd ..
          echo "::notice::Sync verification passed"
          echo "::endgroup::"
          return 0
        }

        cleanup_failed_sync() {
          echo "::notice::Cleaning up failed sync attempt"

          # 重置Git状态
          git reset --hard HEAD 2>/dev/null || true
          git clean -fd 2>/dev/null || true

          # 清理子模块
          if [[ -d "$SUBMODULE_PATH" ]]; then
            git submodule deinit -f "$SUBMODULE_PATH" 2>/dev/null || true
            git rm -f "$SUBMODULE_PATH" 2>/dev/null || true
            rm -rf "$SUBMODULE_PATH" 2>/dev/null || true
          fi

          # 清理Git模块缓存
          rm -rf ".git/modules/$SUBMODULE_PATH" 2>/dev/null || true

          # 清理.gitmodules
          if [[ -f ".gitmodules" ]] && git config -f .gitmodules --get "submodule.$SUBMODULE_PATH.path" >/dev/null 2>&1; then
            git config -f .gitmodules --remove-section "submodule.$SUBMODULE_PATH" 2>/dev/null || true
            if [[ ! -s ".gitmodules" ]]; then
              rm -f ".gitmodules"
            fi
          fi
        }

        # ============================================================================
        # 主执行逻辑
        # ============================================================================

        echo "::group::Enhanced Submodule Sync"
        echo "::notice::Starting reliable sync for $SUBMODULE_PATH"
        echo "::notice::Remote URL: $SUBMODULE_URL"
        echo "::notice::Max retries: $MAX_RETRIES"

        # 记录初始状态
        OLD_COMMIT=""
        if [[ -d "$SUBMODULE_PATH" ]]; then
          cd "$SUBMODULE_PATH"
          OLD_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "")
          CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
          echo "::notice::Current submodule commit: $OLD_COMMIT"
          echo "::notice::Current submodule branch: $CURRENT_BRANCH"
          cd ..
        else
          echo "::notice::Submodule directory does not exist"
        fi

        # 获取远程最新提交
        echo "::notice::Fetching latest commit from remote"
        LATEST_REMOTE_COMMIT=""
        for i in $(seq 1 $MAX_RETRIES); do
          if LATEST_REMOTE_COMMIT=$(git ls-remote "$SUBMODULE_URL" HEAD | cut -f1 2>/dev/null); then
            echo "::notice::Remote latest commit: $LATEST_REMOTE_COMMIT"
            break
          else
            echo "::warning::Failed to fetch remote commit (attempt $i/$MAX_RETRIES)"
            if [[ $i -eq $MAX_RETRIES ]]; then
              echo "::error::Cannot fetch remote commit after $MAX_RETRIES attempts"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            sleep $RETRY_DELAY
          fi
        done

        # 执行同步操作（总是执行，以确保子模块在正确的分支上）
        SYNC_SUCCESS=false
        for attempt in $(seq 1 $MAX_RETRIES); do
          echo "::notice::Sync attempt $attempt/$MAX_RETRIES"

          if sync_submodule; then
            echo "::notice::Sync attempt $attempt succeeded"

            # 验证同步结果
            if verify_sync_result; then
              echo "::notice::Sync verification passed"
              SYNC_SUCCESS=true
              break
            else
              echo "::warning::Sync verification failed"
            fi
          else
            echo "::warning::Sync attempt $attempt failed"
          fi

          # 如果不是最后一次尝试，清理并重试
          if [[ $attempt -lt $MAX_RETRIES ]]; then
            echo "::notice::Cleaning up for retry"
            cleanup_failed_sync
            sleep $RETRY_DELAY
          fi
        done

        # 检查同步结果
        if [[ "$SYNC_SUCCESS" == true ]]; then
          NEW_COMMIT=$(cd "$SUBMODULE_PATH" && git rev-parse HEAD)
          echo "::notice::Sync completed successfully"
          echo "::notice::Old commit: ${OLD_COMMIT:-<none>}"
          echo "::notice::New commit: $NEW_COMMIT"

          echo "status=success" >> $GITHUB_OUTPUT
          echo "old_commit=${OLD_COMMIT:-none}" >> $GITHUB_OUTPUT
          echo "new_commit=$NEW_COMMIT" >> $GITHUB_OUTPUT
        else
          echo "::error::Failed to sync submodule after $MAX_RETRIES attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "old_commit=${OLD_COMMIT:-none}" >> $GITHUB_OUTPUT
          echo "new_commit=" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "::endgroup::"